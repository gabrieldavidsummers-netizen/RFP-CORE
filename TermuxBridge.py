import subprocess\nimport os\nimport shlex\nimport logging\n\n# Configure basic logging for the APKs Python layer\nlogging.basicConfig(level=logging.INFO, format=%(asctime)s - %(levelname)s - %(message)s)\n\nclass TermuxBridge:\n    """\n    TermuxBridge: A Python class designed to run Termux commands from within a\n    custom Android APKs Python layer, bypassing typical shell execution limitations.\n\n    This class assumes the Termux:API and/or Termux:Widget components are available\n    for robust command execution using Android Intents (recommended) or direct\n    Subprocess calls (less reliable in constrained environments).\n    """\n\n    def __init__(self, use_intent_api=False):\n        """\n        Initializes the bridge.\n        :param use_intent_api: If True, attempts to use am start for Termux Intents.\n                               If False, falls back to direct subprocess execution.\n        """\n        self.use_intent_api = use_intent_api\n        logging.info(f"TermuxBridge initialized. Intent API usage: {use_intent_api}")\n\n    def execute_command_intent(self, command: str, run_in_background=True) -> bool:\n        """\n        (Recommended Method) Executes a Termux command using the Android Intent mechanism.\n        Requires the Termux:API Add-on to be installed for termux-open-url or am start methods.\n\n        :param command: The shell command string to execute (e.g., "git pull").\n        :param run_in_background: If True, uses the TERMUX_SERVICE to run silently.\n        :return: True if the intent command was successfully dispatched.\n        """\n        logging.info(f"Attempting Intent execution for command: {command}")\n        \n        try:\n            # We use am start to send the intent\n            intent_cmd = (\n                f"am start "\n                f"-n com.termux/.app.TermuxActivity "\n                f"--es com.termux.RUN_COMMAND \\"{command}\\" "\n                f"--ez com.termux.RUN_IN_NEW_SESSION false"\n            )\n            \n            if run_in_background:\n                pass\n\n            result = subprocess.run(\n                shlex.split(intent_cmd),\n                check=True,\n                capture_output=True,\n                text=True\n            )\n            logging.info(f"Intent dispatched successfully. Output: {result.stdout.strip()}")\n            return True\n\n        except subprocess.CalledProcessError as e:\n            logging.error(f"Intent dispatch failed. Error: {e.stderr.strip()}")\n            return False\n        except FileNotFoundError:\n            logging.error("Android am command not found. Ensure path is correct in APK environment.")\n            return False\n\n    def execute_command_subprocess(self, command: str) -> dict:\n        """\n        (Fallback Method) Executes a command directly using Pythons subprocess.\n        This is less robust for Termux integration but necessary if Intent API is unavailable.\n        \n        :param command: The shell command string to execute (e.g., "ls -l").\n        :return: Dictionary containing stdout, stderr, and return code.\n        """\n        logging.info(f"Attempting Subprocess execution for command: {command}")\n        try:\n            result = subprocess.run(\n                command,\n                shell=True,\n                check=True,\n                capture_output=True,\n                text=True,\n                timeout=10\n            )\n            logging.info(f"Command executed successfully. RC: {result.returncode}")\n            return {\n                "stdout": result.stdout.strip(),\n                "stderr": result.stderr.strip(),\n                "returncode": result.returncode\n            }\n        except subprocess.CalledProcessError as e:\n            logging.error(f"Command failed. RC: {e.returncode}. Stderr: {e.stderr.strip()}")\n            return {\n                "stdout": e.stdout.strip(),\n                "stderr": e.stderr.strip(),\n                "returncode": e.returncode\n            }\n        except Exception as e:\n            logging.critical(f"Execution failed due to system error: {e}")\n            return {\n                "stdout": "",\n                "stderr": f"System execution error: {e}",\n                "returncode": -1\n            }\n\n    def run_termux_shell(self, command: str) -> dict:\n        """\n        The primary public method to execute a command, choosing the best method.\n        """\n        if self.use_intent_api:\n            # For critical background tasks (like starting the http-server)\n            success = self.execute_command_intent(command)\n            return {"status": "Intent Dispatched", "success": success}\n        else:\n            # For commands where immediate output is needed (like ls or cat)\n            return self.execute_command_subprocess(command)\n\nif __name__ == "__main__":\n    bridge_subprocess = TermuxBridge(use_intent_api=False)\n    \n    print("\\n--- Testing Subprocess Command (Read File) ---")\n    ls_result = bridge_subprocess.run_termux_shell("ls -l /data/data/com.termux/files/home/RFP-CORE/Maestro_Gator.html")\n    print(f"Stdout:\\n{ls_result[stdout]}")\n    print("-" * 20)
